# HotSpot JVM内存管理

## 垃圾收集概念

GC做三件事

- 分配内存
- 确保在使用的对象的内存还在
- 释放不再使用对象的空间

GC Roots引用的对象成为**活的**，不再被引用的就是**死的**

GC Roots：

- 当前各线程执行方法局部变量引用的对象
- 被加载类static域引用的对象
- 方法区中常量引用的对象
- JNI引用

GC管理内存成为**堆**

当 stop-the-world 垃圾收集器工作的时候，应用将完全被挂起

stop-the-world 垃圾收集器比并发收集器简单很多，因为应用挂起后**堆空间不再发生变化**，它的缺点是在某些场景下挂起的时间我们是不能接受的（如 web 应用）

### 分代收集介绍

## J2SE 5.0 HotSpot JVM 中的垃圾收集器

包括**串行收集器**、**并行收集器**、**并行压缩收集器** 和 **CMS 垃圾收集器**

### HotSpot 分代

在 HotSpot 虚拟机中，内存被组织成三个分代：年轻代、老年代、永久代。

大部分对象初始化的时候都是在年轻代中的。

老年代存放经过了几次年轻代垃圾收集依然还活着的对象，还有部分大对象因为比较大所以分配的时候直接在老年代分配。

永久代，通常也叫 **方法区**，用于存储已加载类的元数据，以及存储运行时常量池等。

### 垃圾回收类型

当年轻代被填满后，会进行一次年轻代垃圾收集（也叫做 **minor GC**）。

当老年代或永久代被填满了，会触发 **full GC**（也叫做 **major GC**），full GC 会收集所有区域

### 串行收集器

使用串行收集器，年轻代和老年代都使用单线程进行收集（使用一个 CPU），收集过程中会 stop-the-world

年轻代分为**一个 Eden 区和两个 Survivor 区（From 区和 To 区）**

### 并行收集器

现在大多数 Java 应用都运行在大内存、多核环境中，**并行收集器**，也就是大家熟知的**吞吐量收集器**，利用多核的优势来进行垃圾收集，而不是像串行收集器一样将程序挂起后只使用单线程来收集垃圾。

### Concurrent Mark-Sweep（CMS）收集器

**在年轻代中使用 CMS 收集器**

在年轻代中，CMS 和 **并行收集器** 一样，即：**并行、stop-the-world、复制**。

**在老年代中使用 CMS 收集器**

在老年代的垃圾收集过程中，大部分收集任务是和应用程序**并发**执行的。

**何时使用 CMS 收集器**

适用于应用程序要求低停顿，同时能接受在垃圾收集阶段和垃圾收集线程一起共享 CPU 资源的场景，典型的就是 web 应用了。

## 小结

串行收集器：在年轻代和老年代都采用单线程，年轻代中使用 **stop-the-world、复制** 算法；老年代使用 **stop-the-world、标记 -> 清理 -> 压缩** 算法。

并行收集器：在年轻代中使用 **并行、stop-the-world、复制** 算法；老年代使用串行收集器的 **串行、stop-the-world、标记 -> 清理 -> 压缩** 算法。

并行压缩收集器：在年轻代中使用并行收集器的 **并行、stop-the-world、复制** 算法；老年代使用 **并行、stop-the-world、标记 -> 清理 -> 压缩** 算法。和并行收集器的区别是老年代使用了并行。

CMS 收集器：在年轻使用并行收集器的 **并行、stop-the-world、复制** 算法；老年代使用 **并发、标记 -> 清理** 算法，不压缩。本文介绍的唯一一个并发收集器，也是唯一一个不对老年代进行压缩的收集器。



# G1垃圾收集器

G1 的主要关注点在于**达到可控的停顿时间**

CMS的区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间

## G1 总览

 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色

G1 使用了**停顿预测模型**来满足用户指定的停顿时间目标

## G1 工作流程

 G1 的收集过程，G1 收集器主要包括了以下 4 种操作：

- 1、年轻代收集
- 2、并发收集，和应用线程同时执行
- 3、混合式垃圾收集
- 4、必要时的 Full GC

## G1 参数配置和最佳实践

G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间

有以下几点我们可以进行调整的方向：

- 增加堆大小，或调整老年代和年轻代的比例，这个很好理解
- 增加并发周期的线程数量，其实就是为了加快并发周期快点结束
- 让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）
- 在混合垃圾回收周期中回收更多的老年代区块

# 深入理解堆外内存 Metaspace

永久代主要存放以下数据：

- JVM internal representation of classes and their metadata
- Class statics
- Interned strings

## 1、什么是 Metaspace











