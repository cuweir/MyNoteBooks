# Java基础

## final关键字

使用前必须初始化

1. final参数

不能改变参数指向的对象或基本类型

2. final方法

防止子类复写

过去出于效率考虑（编译器采用内嵌调用）

private方法隐式指定final

3. final类

不能被继承

类中所有方法隐式指定为final

## 类初始化

类的代码首次使用时加载

构造器方法隐式static

任意一个static成员被访问，就会被加载

## 多态

### 构造器多态方法行为

初始化实际过程：

1. 分配给对象的存储空间初始化为零
2. 调用基类构造器（基类构造器如果有派生类的重写方法，则会调用重写后的方法，在调用派生类构造器**之前**）
3. 按声明顺序初始化成员
4. 调用派生类构造器

## 接口&抽象类

### 抽象类、抽象方法

抽象方法：只有声明没有方法体

抽象类：包含一个或多个抽象方法（充分不必要条件），不包含也可设为抽象类（在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用）

**private abstract**禁止

### 接口创建

只允许抽象方法，不用加**abstract**

Java8允许接口包含默认方法(default)和静态方法

接口属性被隐式指明为**static**和**final**

来自接口的方法必定为**public**，也可以显式声明

### 抽象类和接口

| 特性                 | 接口                                                       | 抽象类                                   |
| -------------------- | ---------------------------------------------------------- | ---------------------------------------- |
| 组合                 | 新类可以组合多个接口                                       | 只能继承单一抽象类                       |
| 状态                 | 不能包含属性（除了静态属性，不支持对象状态）               | 可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法 和 抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 | 必须在子类中实现抽象方法                 |
| 构造器               | 没有构造器                                                 | 可以有构造器                             |
| 可见性               | 隐式 **public**                                            | 可以是 **protected** 或 "friendly"       |

## 内部类

内部类自动拥有对其外部类所有成员的访问权

> 每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类没有影响

有效地实现了“多重继承”

内部类的其他特性：

1. 可以有多个实例，每个实例都有自己的状态信息，并且与外部类对象的信息相互独立
2. 单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类
3. 创建内部类对象的时刻不依赖于外部类对象的创建
4. 没有”is-a“关系，它就是一个独立的实体



















# Java集合



# JVM

## JMM

### 结构

1. 线程私有区域
   1. PC：当前thread执行字节码的行号指示
   2. 虚拟机栈
      1. 栈帧：
         - 局部变量表
         - 操作数栈
         - 动态链接
         - 方法出口
   3. 本地方法区（C、C++）
2. 线程共享
   1. Java堆
      1. 存储的是数组和对象，new出来的
   2. 方法区
      1. 运行时常量池。类、静态变量、静态方法、常量、普通方法
3. 直接内存

### 运行时内存（堆，分代）

在 HotSpot 虚拟机中，内存被组织成三个分代：年轻代、老年代、永久代。

大部分对象初始化的时候都是在年轻代中的。

老年代存放经过了几次年轻代垃圾收集依然还活着的对象，还有部分大对象因为比较大所以分配的时候直接在老年代分配。

永久代，通常也叫 **方法区**，用于存储已加载类的元数据，以及存储运行时常量池等。

- 新生代（minor GC）
  - Eden区（8/10）
  - From Survivor区
  - To Survivor区
- 老年代（major GC）
- 永久代（Java8被元数据区取代，区别是其使用了本地内存）

### 线程

- 虚拟机线程
- 编译器线程
- 周期性任务线程
- 信号分发线程
- GC线程

## GC

### GC、GCRoots、stop-the-world概念

GC做三件事

- 分配内存
- 确保在使用的对象的内存还在
- 释放不再使用对象的空间

GC Roots引用的对象成为**活的**，不再被引用的就是**死的**

GC Roots：

- 当前各线程执行方法局部变量引用的对象
- 被加载类static域引用的对象
- 方法区中常量引用的对象
- JNI引用

GC管理内存成为**堆**

当 stop-the-world 垃圾收集器工作的时候，应用将完全被挂起

stop-the-world 垃圾收集器比并发收集器简单很多，因为应用挂起后**堆空间不再发生变化**，它的缺点是在某些场景下挂起的时间我们是不能接受的（如 web 应用）

#### GC类型（major、minor）

当年轻代被填满后，会进行一次年轻代垃圾收集（也叫做 **minor GC**）。

当老年代或永久代被填满了，会触发 **full GC**（也叫做 **major GC**），full GC 会收集所有区域

### 垃圾收集器

包括**串行收集器**、**并行收集器**、**并行压缩收集器** 和 **CMS 垃圾收集器**

#### 串行收集器

使用串行收集器，年轻代和老年代都使用单线程进行收集（使用一个 CPU），收集过程中会 stop-the-world

年轻代分为**一个 Eden 区和两个 Survivor 区（From 区和 To 区）**

#### 并行收集器

现在大多数 Java 应用都运行在大内存、多核环境中，**并行收集器**，也就是大家熟知的**吞吐量收集器**，利用多核的优势来进行垃圾收集，而不是像串行收集器一样将程序挂起后只使用单线程来收集垃圾。

#### Concurrent Mark-Sweep（CMS）收集器

**在年轻代中使用 CMS 收集器**

在年轻代中，CMS 和 **并行收集器** 一样，即：**并行、stop-the-world、复制**。

**在老年代中使用 CMS 收集器**

在老年代的垃圾收集过程中，大部分收集任务是和应用程序**并发**执行的。

**何时使用 CMS 收集器**

适用于应用程序要求低停顿，同时能接受在垃圾收集阶段和垃圾收集线程一起共享 CPU 资源的场景，典型的就是 web 应用了。

#### 小结

串行收集器：在年轻代和老年代都采用单线程，年轻代中使用 **stop-the-world、复制** 算法；老年代使用 **stop-the-world、标记 -> 清理 -> 压缩** 算法。

并行收集器：在年轻代中使用 **并行、stop-the-world、复制** 算法；老年代使用串行收集器的 **串行、stop-the-world、标记 -> 清理 -> 压缩** 算法。

并行压缩收集器：在年轻代中使用并行收集器的 **并行、stop-the-world、复制** 算法；老年代使用 **并行、stop-the-world、标记 -> 清理 -> 压缩** 算法。和并行收集器的区别是老年代使用了并行。

CMS 收集器：在年轻使用并行收集器的 **并行、stop-the-world、复制** 算法；老年代使用 **并发、标记 -> 清理** 算法，不压缩。本文介绍的唯一一个并发收集器，也是唯一一个不对老年代进行压缩的收集器。

### G1

G1 的主要关注点在于**达到可控的停顿时间**

CMS的区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间

#### G1 总览

 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色

G1 使用了**停顿预测模型**来满足用户指定的停顿时间目标

#### G1 工作流程

 G1 的收集过程，G1 收集器主要包括了以下 4 种操作：

- 1、年轻代收集
- 2、并发收集，和应用线程同时执行
- 3、混合式垃圾收集
- 4、必要时的 Full GC

#### G1 参数配置和最佳实践

G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间

有以下几点我们可以进行调整的方向：

- 增加堆大小，或调整老年代和年轻代的比例，这个很好理解
- 增加并发周期的线程数量，其实就是为了加快并发周期快点结束
- 让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）
- 在混合垃圾回收周期中回收更多的老年代区块

### Metaspace元空间























# 多线程









# MySQL





# Redis















# Spring





# 消息队列



# ZooKeeper



# 算法



















