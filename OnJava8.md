# 1.对象的概念

…………

# 2. 安装Java和本书用例

gradle

# 3. 万物皆对象

## 数据存储

1. 寄存器
2. 栈内存（RAM）：Java系统必须知道栈内保存的所有项的生命周期
3. 堆内存（RAM）：灵活，编译器不需知道对象在堆内存中的停留时间。代价：分配和清理比栈慢。
4. 常量存储
5. 非RAM存储：序列化对象、持久化对象

## 基本类型

栈内存中

## 高精度数值

BigInteger

BigDecimal

## 基本类型默认值

仅在Java初始化类的时候才会被赋予

# 4. 运算符

## 测试对象等价

Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 `==` 和 `!=` 比较也能能到正确的结果，但是不推荐用关系运算符比较，具体见 JDK 中的 Integer 类源码）。

## 移位运算符

'>>>'右移位运算符，无论正负，高位补0

# 5. 控制流

## goto语句

```java
label1:
outer-iteration { 
  inner-iteration {
  // ...
  break; // [1] 
  // ...
  continue; // [2] 
  // ...
  continue label1; // [3] 
  // ...
  break label1; // [4] 
  } 
}

```

# 6. 初始化和清理

## this关键字

## 垃圾回收器

不等于析构

## 初始化的顺序

初始化一个类：先按照顺序初始化变量，再调用构造器

## 构造器初始化

静态初始化只在必要时才会进行，如：不创建对象不引用类中的静态类变量，不会初始化静态类

静态块：仅执行一次

### 非静态实例初始化

类似于静态块，用来初始化非静态变量，也在构造器之前执行

# 7. 封装

## 接口和实现

访问控制也被称为隐藏实现implementation hiding

出于两个原因：1. 确立客户端程序员可以使用和不能使用的边界；2. 将接口与实现分离

## 类访问权限

每个文件只有一个public类，没有public类是可能的

类只能是public和default

# 8. 复用

## 继承语法

### 初始化基类

基类先初始化

## 组合与继承的选择

是一个——继承

有一个——组合

## 向上转型

安全的

### 再讨论继承与组合

继承其实并不常用

如果必须向上转型，那么继承是必要的

## final关键字

### 空白final

使用前必须初始化

类中定义了空白final变量，则构造器中必须将其初始化

### final参数

意味着在方法中不能改变参数指向的对象或基本变量（只能读不能改）

### final方法

防止子类覆写该方法

过去也出于效率考虑，过去编译器对final方法采用内嵌调用

private方法隐式指定为final

### final类

不能被继承，类中所有方法隐式指定为final

## 类初始化和加载

类的代码在首次使用时加载

构造器也是static方法，static关键字是隐式的

因此，准确地说，一个类当它任意一个 **static** 成员被访问时，就会被加载。

# 9. 多态

## 转机

### 方法调用绑定

将一个方法调用和一个方法主体关联起来称作*绑定*

后期绑定，动态绑定

Java除了static和final方法都是后期绑定

## 构造器和多态

### 构造器内部多态方法的行为

初始化实际过程：

1. 分配给对象的存储空间初始化为零
2. 调用基类构造器（基类构造器如果有派生类的重写方法，则会调用重写后的方法，在调用派生类构造器**之前**）
3. 按声明顺序初始化成员
4. 调用派生类构造器

因此，编写构造器：尽量不要用到类中的任何方法，安全调用的只有基类的final方法（不会被重写）

## 协变返回类型

Java5允许派生类的被重写方法可以返回基类方法返回类型的派生类

## 使用继承设计

通用准则：使用继承表达行为差异，使用属性表达状态的变化

# 10. 接口

## 抽象类和方法

抽象方法：只有声明没有方法体

抽象类：包含一个或多个抽象方法（充分不必要条件），不包含也可设为抽象类（在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用）

**private abstract**禁止

## 接口创建

只允许抽象方法，不用加**abstract**

建立了类之间的协议

Java8允许接口包含默认方法和静态方法

接口属性被隐式指明为**static**和**final**

来自接口的方法必定为**public**，也可以显式声明。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是 Java 编译器所不允许的。

### 默认方法

Java8允许关键字**default**在接口中提供方法实现

### 多继承

Java通过默认方法具有了某种多继承的特性

### 接口中的静态方法

Java8允许接口中添加静态方法，这样可以恰当地把工具功能置于接口中。设计模式：模板方法

## 抽象类和接口

| 特性                 | 接口                                                       | 抽象类                                   |
| -------------------- | ---------------------------------------------------------- | ---------------------------------------- |
| 组合                 | 新类可以组合多个接口                                       | 只能继承单一抽象类                       |
| 状态                 | 不能包含属性（除了静态属性，不支持对象状态）               | 可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法 和 抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 | 必须在子类中实现抽象方法                 |
| 构造器               | 没有构造器                                                 | 可以有构造器                             |
| 可见性               | 隐式 **public**                                            | 可以是 **protected** 或 "friendly"       |

## 多接口结合

使用接口的核心原因：为了向上转型为多个基类型；防止客户端程序员创建这个类的对象。

**接口**or**抽象类**？

创建不带任何方法定义或成员变量的基类，选择接口。

## 接口适配

策略模式

## 接口和工厂方法模式

可以将接口与实现的代码完全分离

# 11. 内部类

## 创建内部类

外部类的非静态方法中创建内部类对象需要指明对象类型：OuterClassName.InnerClassName

## 链接外部类

内部类自动拥有对其外部类所有成员的访问权

当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后，在你访问此外部类的成员时，就是用那个引用来选择外部类的成员。

内部类的对象只能在与其外部类的对象相关联的情况下才能被创建（就像你应该看到的，内部类是非 **static** 类时）。构建内部类对象时，需要一个指向其外部类对象的引用，如果编译器访问不到这个引用就会报错。不过绝大多数时候这都无需程序员操心。

## 使用.this和.new

生成对外部类对象的引用，可以使用外部类的名字后面跟.this。

创建某个内部类对象需要.new语法：

```java
// innerclasses/DotNew.java
// Creating an inner class directly using .new syntax
public class DotNew {
    public class Inner {}
    public static void main(String[] args) {
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();
    }
}
```

在拥有外部类对象之前是不可能创建内部类对象的，因为内部类对象会暗暗地连接到建它的外部类对象上。

但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。

## 内部类方法和作用域

可以在任意一个方法或作用域内定义内部类，这样做的理由：

1. 实现了某类型的接口，就可以创建并返回对其的引用
2. 想创建一个类辅助解决问题，但又不希望这个类是公共可用的

## 匿名内部类

 与正规的继承相比有些受限，要么继承类，要么实现接口，而且实现接口只能实现一个接口。

## 嵌套类

讲内部类声明为**static**，这意味着：

1. 创建嵌套类对象不需要外部类对象
2. 不能从嵌套类对象中访问非静态的外部类对象

普通内部类不能有static数据和static字段，也不能包含嵌套类；但是嵌套类都可以有

### 接口内部的类

嵌套类可作为接口的一部分

## 为什么需要内部类

> 每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类没有影响

有效地实现了“多重继承”

内部类的其他特性：

1. 可以有多个实例，每个实例都有自己的状态信息，并且与外部类对象的信息相互独立
2. 单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类
3. 创建内部类对象的时刻不依赖于外部类对象的创建
4. 没有”is-a“关系，它就是一个独立的实体

### 闭包与回调

closure

callback

内部类是面向对象的闭包

## 内部类可以被重写吗？

无效

因为继承某个外部类的时候，内部类不会发生变化，两个内部类是完全独立的实体，各自在自己的命名空间中。

## 局部内部类

和匿名内部类比较，可以实现相同的行为

既然局部内部类名字在方法外不可见，为什么要用？

1. 需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能使用实例初始化
2. 需要不止一个该内部类对象

## 内部类标识符

内部类也必须产生一个**.class**文件，命名规则：

外部类名字$内部类名字.class

# 12. 集合

## 泛型和类型安全的集合

Java5前的集合：编译器允许你向集合中插入不正确的类型

表达式右侧的菱形语法：new ArrayList<>(); 

Java7之前必须在两端都进行类型声明：

```java
ArrayList<Apple> apples = new ArrayList<Apple>();
```

## 添加元素组

Arrays.asList()

Collections.addAll()

## 列表List

subList()，创建切片

containsAll()，和顺序无关

retainAll()，取交集

set(a, b)，b替换索引a处的元素

## 迭代器Iterators

迭代器的概念也是一种设计模式。

它是一个对象，轻量级对象，创建代价小。

Java的Iterator只能单向移动，一般用来：

1. iterator()方法返回一个Iterator，准备好返回序列中第一个元素
2. next()方法获得序列中的下一个元素
3. hasNext()序列中是否还有元素
4. remove()将迭代器最近返回的那个元素删除

迭代器统一了集合的访问方式

Iterable接口

### ListIterator

Iterator子类型，可以双向移动，只能由List类生成

## 链表LinkedList

添加了一些方法，使其可以被用作栈、队列或双端队列

## 堆栈Stack

Java1.0设计的Stack类很糟糕

Java6添加了ArrayDeque

## 队列Queue

LinkedList实现了Queue

offer()队尾插入元素

peek()和element()返回队头元素，peek()为空返回null，element()为空抛异常

poll()和remove()删除并返回队头元素，poll()为空返回null，remove()抛异常

### 优先级队列PriorityQueue

Java5添加，队头元素优先级最高

## 集合与迭代器

AbstractCollection提供了Collection的默认实现

如果实现了Collection，就必须也实现iterator()

生成 **Iterator** 是将序列与消费该序列的方法连接在一起的耦合度最小的方式，并且与实现 **Collection** 相比，它在序列类上所施加的约束也少得多

## for-in和迭代器

适用于任何Collection对象

Java5引入一个**Iterable**的接口，该接口包含一个能够生成 **Iterator** 的 `iterator()` 方法。*for-in* 使用此 **Iterable** 接口来遍历序列

如果创建了任何实现了 **Iterable** 的类，都可以将它用于 *for-in* 语句中

所以Collection类都是Iterable

# 13. 函数式编程

OO是抽象数据

FP（functional programming）是抽象行为

## 方法引用

类名或对象名::方法名

## 函数式接口

@FunctionalInterface

`java.util.function` 包，包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为 *函数式方法* 。

## 高阶函数

消费或产生函数

